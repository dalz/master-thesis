\chapter{Related work}
\label{ch:related-work}

To the best of our knowledge there is no previous work on formal verification of the \msp, neither its ISA nor machine programs. Here we discuss the closest: previous uses of Katamaran and other verification approaches in the context of machine-readable ISA specifications.

\subsection{Katamaran case studies}

Katamaran has been applied to two case studies before this \cite{Huyghebaert2023}: MinimalCaps, a custom capability-based architecture, and a simplified version of RISC-V with the Physical Memory Protection (PMP) extension.

While there are open-source chip designs with PMP support \cite{ChipsAlliance}, they have limited or no commercial availability. So this work marks the first time Katamaran has been applied to a widely used architecture.

Moreover, the \usail models of both MinimalCaps and RISC-V PMP were developed by hand alongside the proof of their security properties. Here we instead started from an existing Sail specification, automatically translated to \usail, which will likely be the preferred flow for future verification of non-toy architectures.

On the other hand the present work is incomplete compared to the previous case studies, as it is missing the lemma and foreign function verification in the Iris model.

The security property we proved is similar to the one for RISC-V PMP, but there the universal contract takes into account changes of privilege after certain events such as traps. As for MinimalCaps, capability safety requires a different approach since there isn't a fixed protected regions. Instead unprivileged code can only access locations for which it holds (in one of the registers) a matching capability. Thus instead of assuming ownership of all unprotected locations the universal contract gives points-to chunks corresponding to the capabilities currently stored in the registers.

\subsection{Other verification frameworks}

Many before us have tackled the verification of various properties of ISAs and assembly programs. Until recently most designed their own abstract model (\eg as operational semantics) of the subset of the architecture that was relevant for their specific objective---see for example \cite{Georges2021}\cite{Jensen2013}\cite{Guanciale2016}. However, the availability of formal specifications for Armv8-A and RISC-V \cite{Armstrong2019} has in the last few years sparked the development of verification tools that work with Sail or other specification languages. In addition to being architecture-agnostic and reducing the effort required by the verification, these tools provide better guarantees than previous approaches by virtue of using complete and authoritative specifications in place of ad-hoc models. We focus on the latter class of tools which includes Katamaran.

In \cite{Simner2020} multithreaded Sail programs are translated to SMT problems that have the possible execution outcomes (in terms of register and memory values) as solutions. These were then used to validate a proposed microarchitectural model of instruction fetch in Armv8-A against its ISA.

According to \cite{Armstrong2021} this approach does not scale to full-fledged Sail specifications. They instead develop \intro{Isla}, a symbolic executor for Sail code, which integrates with the Z3 SMT solver to prune unreachable branches. The performance boost from this hybrid approach allows Isla to work directly on the entire Armv8-A Sail specification. The tool was designed to explore the outcomes of executing parallel assembly code under user-defined memory models, but the authors remark that the symbolic executor is general-purpose and could be applied to other verification tasks.

\intro{Islaris} \cite{Sammler2022} builds on top of Isla to verify properties of assembly programs. The idea is to use Isla to produce a trace of register and memory accesses via symbolic execution, then turn the trace into a Rocq value. The user can express the desired property (on the event trace or final state) in a separation logic based on Iris and prove it in Rocq. Islaris also provides proof automation supported by the use of a restricted fragment of separation logic based on Lithium \cite{Sammler2021}.

There is some overlap in functionality between Katamaran and Islaris. The latter focuses solely on verification of concrete machine code, \ie is comparable in scope to Katamaran's block verifier. The intended workflow of the two tools is similar: Islaris' proof automation and Katamaran's solver try to reduce the goal as much as possible, and the residual verification conditions are left for the user to prove. Islaris is better in some aspects:
\begin{itemize}
\item Through Isla, it takes advantage of Z3 for state simplification. Z3 is a mature, widely used project, and likely performs better than Katamaran's custom solver.
\item Islaris has been succesfully applied to the Armv8-A Sail specification, a much more complex case study than any of Katamaran's. It is doubtful that Katamaran's block verifier could handle it in its current state of development.
\item Islaris is not restricted to basic blocks. Katamaran requires additional manual proofs (in the underlying Iris model) to obtain a result about a branching program.
\item Islaris' logic is higher order, and can assert in its propositions the validity of a Hoare double (which they use instead of triples) at a given instruction address. Katamaran can express this in the Iris model but not in its own first-order logic, meaning that the symbolic executor cannot reason about such properties. % TODO You have to hide it behind an abstract predicate. "cannot" is a bit strong
\end{itemize}

On the other hand Katamaran is implemented in Rocq and verified to be correct---this is the motivation behind it not using Z3---so it provides greater assurance. To remove the need to trust Isla, Islaris' developers have experimented with a translation validation approach: they translated the Sail specification to Rocq (using Sail's built-in backend) and proved for some traces produced by Isla that they are compatible with the Rocq model.\footnote{More precisely that the behaviors of the Rocq model refine the traces.} This proof requires manual intervention, particularly whenever Rocq's automation isn't capable of checking some fact derived by Z3, somewhat negating the benefits of using Isla and Z3 in the first place. Additionally this strategy was initially trialed on the RISC-V specification, and was later found infeasible with Armv8-A, due to Rocq having trouble handling the large generated model.

It is worth noting that the translation validation approach relies on the correctness of the translation from Sail, which is not verified. Indeed the authors discovered a bug in the generated model during the experimentation on RISC-V. The same could be said about Katamaran's translation to \usail. In principle both backends could be proved correct, increasing trust in the tools.

Overall, Islaris has better scalability and Katamaran is more trustworthy. It is unclear whether Islaris could provide complete assurance without losing its benefits, and how much improvements in usability to Katamaran will be hindered by the need for formally verifying every change.

For another approach \cite{Nelson2019} presents \intro{Serval}, which focuses on push-button (\ie fully automated via symbolic execution and SMT) verification of assembly code. Serval works with user-defined architectures by taking as input a machine-code interpreter written in the Rosetta language. Instead of expressing the property to prove via a program logic, Serval checks that all possible execution outcomes refine a given abstract state. General limitations of push-button approaches apply, particularly on the complexity of the target code, ISA and property---the Rosetta models described in \cite{Nelson2019} are a few thousands lines long, one or two order of magnitude less than the largest production Sail specifications.

As we have seen Katamaran is not limited to proving properties about concrete assembly programs, instead having been designed to verify separation logic triples on Sail functions. Islaris and Serval rely on the constraints imposed by known code to scale effectively to larger specifications, and consider properties about arbitrary instructions (like our universal contract) out of scope. There is value in having a single tool handle both tasks: the universal contract can be easily reused to verify concrete code that jumps to arbitrary (attacker-controlled) code.

Other work has focused on proofs on ISA specifications only, disregarding assembly programs. Sail can produce theorem prover definitions which can be used to verify the desired properties, as exemplified by the proof of capability monotonicity of the Arm Morello architecture in \cite{Bauereiss2022}. There the proof is conducted almost entirely in Isabelle/HOL (with the aid of an SMT solver in one specific case), using tactics to automate the trivial steps. Part of their contribution was to define a sufficiently abstract characterization of some of the security guarantees of hardware capabilities; the abstraction is crucial for the feasibility of the verification.

Katamaran differs fundamentally from this approach by working with a deeply embedded specification (\usail) and logic via a custom symbolic executor and solver. Katamaran's bet is that not beign tied to the theorem prover as a metalogic will enable better optimizations---at the very least, the ability to extract the executor to a more performant language. This should allow the verification of more precise properties. The execution time reported in \cite{Bauereiss2022} is more than 7 hours (halved with multi-threading), so improvements on this front could also meaningfully speed up iterative development of the proof. That said Katamaran has yet to be tested on such a large specification.





% bello da dire nel block verifier:
% Our examples are not large in instruction count, but direct proofs above the Arm and RISC-V ISA models would require reasoning about many thousands of lines of those specifications, and they involve many system registers
