\chapter{Related work}
\label{ch:related-work}

To the best of our knowledge there is no previous work on formal verification of the \msp, neither its ISA nor machine programs. On the other hand there is a vast amount of existing work in this area targeting other architectures. Here we discuss some of it, restrincting the scope to those dealing with concrete machine-readable ISA specification, taking advantage of symbolic execution and aiming to build reusable frameworks.

\section{Katamaran case studies}

Katamaran has been applied to two case studies before this \cite{Huyghebaert2023}: MinimalCaps, a custom capability-based architecture, and a simplified version of RISC-V with the Physical Memory Protection (PMP) extension. While some RISC-V PMP chips are commercially available \cite{XuanTie}, the \msp is more widely used by a large margin.

The \usail models of both MinimalCaps and RISC-V PMP were developed by hand alongside the proof of their security properties. Here we instead started from an existing Sail specification which is then automatically translated to \usail; this will likely be the preferred flow for future verifications of non-toy architectures.

On the other hand the present work is incomplete compared to the previous case studies, as it is missing the lemma and foreign function verification in the Iris model.

The security property we proved is similar to the one for RISC-V PMP, but there the universal contract takes into account changes of privilege after certain events such as traps. As for MinimalCaps, capability safety requires a different approach since there isn't a fixed protected region. Instead unprivileged code can only access locations for which it holds (in one of the registers) a matching capability. Thus instead of assuming ownership of all unprotected locations the universal contract gives points-to chunks corresponding to the capabilities currently stored in the registers.

\section{Other verification frameworks}

Many before us have tackled the verification of various properties of ISAs and assembly programs. Until recently most designed their own abstract model (\eg as operational semantics) of the subset of the architecture that was relevant for their specific objective---see for example \cite{Georges2021}\cite{Jensen2013}\cite{Guanciale2016}. However, the availability of formal specifications for Armv8-A and RISC-V \cite{Armstrong2019} has in the last few years sparked the development of verification tools that work with Sail or other specification languages. In addition to being architecture-agnostic and reducing the effort required by the verification, these tools provide better guarantees than previous approaches by virtue of using complete and authoritative specifications in place of ad-hoc models. We focus on the latter class of tools which includes Katamaran.

In \cite{Simner2020} multithreaded Sail programs are translated to SMT problems that have the possible execution outcomes (in terms of register and memory values) as solutions. These were then used to validate a proposed microarchitectural model of instruction fetch in Armv8-A against its ISA.

According to \cite{Armstrong2021} this approach does not scale to full-fledged Sail specifications. They instead develop \intro{Isla}, a symbolic executor for Sail code, which integrates with the Z3 SMT solver to prune unreachable branches. The performance boost from this hybrid approach allows Isla to work directly on the entire Armv8-A Sail specification. The tool was designed to explore the outcomes of executing parallel assembly code under user-defined memory models, but the authors remark that the symbolic executor is general-purpose and could be applied to other verification tasks.

\intro{Islaris} \cite{Sammler2022} builds on top of Isla to verify properties of assembly programs. The idea is to use Isla to produce a trace of register and memory accesses via symbolic execution, then turn the trace into a Rocq value. The user can express the desired property (on the event trace or final state) in a separation logic based on Iris and prove it in Rocq. Islaris also provides proof automation supported by the use of a restricted fragment of separation logic based on Lithium \cite{Sammler2021}.

There is some overlap in functionality between Katamaran and Islaris. The latter focuses solely on verification of concrete machine code, \ie is comparable in scope to Katamaran's block verifier. The intended workflow of the two tools is similar: Islaris' proof automation and Katamaran's solver try to reduce the goal as much as possible, and the residual verification conditions are left for the user to prove. Islaris is better in some aspects:
\begin{itemize}
\item Through Isla, it takes advantage of Z3 for state simplification. Z3 is a mature, widely used project, and likely performs better than Katamaran's custom solver.
\item Islaris has been succesfully applied to the Armv8-A Sail specification, a much more complex case study than any of Katamaran's. It is doubtful that Katamaran's block verifier could handle it in its current state of development.
\item Islaris is not restricted to basic blocks. Katamaran requires additional manual proofs (in the underlying Iris model) to obtain a result about a branching program.
\item Islaris' logic is higher order, and can assert in its propositions the validity of a Hoare double (which they use instead of triples) at a given instruction address. Katamaran can express this only as a custom predicate, meaning that some additional work is then required to prove sound the lemmas that operate on it.
\end{itemize}

On the other hand Katamaran is implemented in Rocq and verified to be correct---this is the motivation behind it not using Z3---so it provides greater assurance. To remove the need to trust Isla, Islaris' developers have experimented with a translation validation approach: they translated the Sail specification to Rocq (using Sail's built-in backend) and proved for some traces produced by Isla that they are compatible with the Rocq model.\footnote{More precisely that the behaviors of the Rocq model refine the traces.} This proof requires manual intervention, particularly whenever Rocq's automation isn't capable of checking some fact derived by Z3, somewhat negating the benefits of using Isla and Z3 in the first place. Additionally this strategy was initially trialed on the RISC-V specification, and was later found infeasible with Armv8-A, due to Rocq having trouble handling the large generated model.

It is worth noting that the translation validation approach relies on the correctness of the translation from Sail, which is not verified. Indeed the authors discovered a bug in the generated model during the experimentation on RISC-V. The same could be said about Katamaran's translation to \usail. In principle both backends could be proved correct, increasing trust in the tools.

Overall, Islaris has better scalability and Katamaran is more trustworthy. It is unclear whether Islaris could provide complete assurance without losing its benefits, and how much improvements in usability to Katamaran will be hindered by the need for formally verifying every change.

For another approach \cite{Nelson2019} presents \intro{Serval}, which focuses on push-button (\ie fully automated via symbolic execution and SMT) verification of assembly code. Serval works with user-defined architectures by taking as input a machine-code interpreter written in the Rosetta language. Instead of expressing the property to prove via a program logic, Serval checks that all possible execution outcomes refine a given abstract state. General limitations of push-button approaches apply, particularly on the complexity of the target code, ISA and property---the Rosetta models described in \cite{Nelson2019} are a few thousands lines long, one or two order of magnitude less than the largest production Sail specifications.

\intro{IsaBIL} \cite{Griffin2025} is a Isabelle/HOL formalization of \intro{BAP}'s \cite{Brumley2011} intermediate language BIL for machine code. IsaBIL provides a verified translator from BIL to Isabelle and a tactic library for semi-automated proofs of Hoare and incorrectness logic triples on BIL programs. BIL provides a unified representation for the machine language of a number of architectures (BAP supports lifting of binary code to BIL for x86, Arm, PowerPC and more), so IsaBIL transparently supports all of them. On the other hand the correctness of BAP's lifting is ascertained by testing only, so IsaBIL doesn't take advantage of the available authoritative ISA specifications. IsaBIL also doesn't support (incorrectness) separation logic, and the authors remark that BIL's memory model makes it hard to implement it.

As we have seen Katamaran is not limited to proving properties about concrete assembly programs, instead having been designed to verify separation logic triples on Sail functions. Islaris and Serval rely on the constraints imposed by known code to scale effectively to larger specifications, and consider properties about arbitrary instructions (like our universal contract) out of scope. There is value in having a single tool handle both tasks: the universal contract can be easily reused to verify concrete code that jumps to arbitrary (attacker-controlled) code.

An example of previous work combining ISA and assembly code verification is the proof (mechanized in HOL4) of information flow security of the PROSPER separation kernel for Armv7, presented in \cite{Dam2013}. A separation kernel manages multiple code and data partitions with well-defined communication channels. Their strategy starts with defining an ideal architecture (as a small-step operational semantics) with one distinct processor per software partition, which satisfies the security property by construction. They then define a candidate bisimulation relation between the traces of the ideal architecture and of a model of Armv7 running PROSPER. The proof that the relation is indeed a bisimulation involves both symbolic execution of assembly code, performed by BAP, and verification of certain facts about the ISA itself. The latter include for example that the behavior of unprivileged code doesn't depend on data protected by the MMU, and are proved in HOL4 with bespoke automation developed in HOL4 and Python. The target Armv7 model is an extension of the one presented in \cite{Fox2010}, which is validated but not authoritative. Expressing the security property as a separation logic contract is arguably more straightforward than a custom abstract model, but the latter may be useful in niche cases that are not covered well by fragments of separation logic that are suitable for semi-automated reasoning, possibly some kind of hyperproperty.

Other work has focused on proofs on ISA specifications only, disregarding assembly programs. Sail can produce theorem prover definitions which can be used to verify the desired properties, as exemplified by the proof of capability monotonicity of the Arm Morello architecture in \cite{Bauereiss2022}. There the proof is conducted almost entirely in Isabelle/HOL (with the aid of an SMT solver in one specific case), using tactics to automate the trivial steps. Part of their contribution was to define a sufficiently abstract characterization of some of the security guarantees of hardware capabilities; the abstraction is crucial for the feasibility of the verification.

Katamaran differs fundamentally from this approach by working with a deeply embedded specification (\usail) and logic via a custom symbolic executor and solver. Katamaran's bet is that not beign tied to the theorem prover as a metalogic will enable better optimizations---at the very least, the ability to extract the executor to a more performant language. This should allow the verification of more precise properties. The execution time reported in \cite{Bauereiss2022} is more than 7 hours (halved with multi-threading), so improvements on this front could also meaningfully speed up iterative development of the proof. That said Katamaran has yet to be tested on such a large specification.

It is worth nothing that recently a stronger capability safety property on Arm Morello was proved in \cite{Hammond2025}. The proof extends the aforementioned verification in Isabelle, and the result is then manually translated to Rocq to verify known code with Islaris. In addition to the considerations we already noted on those two project, a limitation of using two different provers is that the result obtained in Isabelle must be admitted in Rocq, and mistakes could be made in the translation.

% TODO seL4?
