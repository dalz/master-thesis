@InProceedings{Bognar2024,
  author     = {Marton Bognar and Cas Magnus and Frank Piessens and Jo Van Bulck},
  booktitle  = {33rd {USENIX} Security Symposium, {USENIX} Security 2024, Philadelphia, PA, USA, August 14-16, 2024},
  title      = {Intellectual Property Exposure: Subverting and Securing Intellectual Property Encapsulation in Texas Instruments Microcontrollers},
  editor     = {Davide Balzarotti and Wenyuan Xu},
  publisher  = {{USENIX} Association},
  url        = {https://www.usenix.org/conference/usenixsecurity24/presentation/bognar},
  bibsource  = {dblp computer science bibliography, https://dblp.org},
  biburl     = {https://dblp.org/rec/conf/uss/BognarMPB24.bib},
  file       = {:bognar24exposure.pdf:PDF},
  groups     = {Katamaran},
  readstatus = {read},
  year       = {2024},
}

@InProceedings{Huyghebaert2023,
  author     = {Sander Huyghebaert and Steven Keuchel and Coen De Roover and Dominique Devriese},
  booktitle  = {Proceedings of the 2023 {ACM} {SIGSAC} Conference on Computer and Communications Security, {CCS} 2023, Copenhagen, Denmark, November 26-30, 2023},
  title      = {Formalizing, Verifying and Applying {ISA} Security Guarantees as Universal Contracts},
  doi        = {10.1145/3576915.3616602},
  editor     = {Weizhi Meng and Christian Damsgaard Jensen and Cas Cremers and Engin Kirda},
  pages      = {2083--2097},
  publisher  = {{ACM}},
  bibsource  = {dblp computer science bibliography, https://dblp.org},
  biburl     = {https://dblp.org/rec/conf/ccs/HuyghebaertKRD23.bib},
  file       = {:uni/bibliography/Huyghebaert2023 - Formalizing, Verifying and Applying ISA Security Guarantees As Universal Contracts.pdf:PDF},
  groups     = {Katamaran},
  readstatus = {read},
  year       = {2023},
}

@Online{Armstrong,
  author  = {Alasdair Armstrong and Thomas Bauereiss and Brian Campbell and Shaked Flur and Kathryn E. Gray and Robert Norton-Wright and Christopher Pulte and Peter Sewell},
  title   = {The Sail instruction-set semantics specification language},
  url     = {https://alasdair.github.io/},
  urldate = {2025-05-10},
}

@Manual{Intel2025,
  author  = {{Intel Corporation}},
  date    = {2025},
  title   = {Intel 64 and IA-32 Architectures Software Developer’s Manual},
  url     = {https://cdrdv2.intel.com/v1/dl/getContent/671200},
  urldate = {2025-05-11},
}

@Manual{AMD2024,
  author  = {AMD},
  date    = {2024},
  title   = {AMD64 Architecture Programmer’s Manual},
  url     = {https://docs.amd.com/v/u/en-US/40332_4.08},
  urldate = {2025-05-11},
}

@Manual{OPF2024,
  author   = {{OpenPOWER Foundation}},
  date     = {2024},
  title    = {Power Instruction Set Architecture},
  subtitle = {Version 3.1C},
  url      = {https://files.openpower.foundation/s/9izgC5Rogi5Ywmm/download/OPF_PowerISA_v3.1C.pdf},
  urldate  = {2025-05-11},
}

@Online{libreSOC,
  author  = {{libreSOC Project}},
  title   = {ISA Pseudo-code},
  url     = {https://libre-soc.org/openpower/isa/},
  urldate = {2025-05-11},
}

@InProceedings{Reid2016,
  author    = {Alastair Reid},
  booktitle = {2016 Formal Methods in Computer-Aided Design, {FMCAD} 2016, Mountain View, CA, USA, October 3-6, 2016},
  date      = {2016},
  title     = {Trustworthy specifications of ARM{\textregistered} v8-A and v8-M system level architecture},
  doi       = {10.1109/FMCAD.2016.7886675},
  editor    = {Ruzica Piskac and Muralidhar Talupur},
  pages     = {161--168},
  publisher = {{IEEE}},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl    = {https://dblp.org/rec/conf/fmcad/Reid16.bib},
  file      = {:Reid2016 - Trustworthy Specifications of ARM_ V8 a and V8 M System Level Architecture.pdf:PDF},
}

@Manual{Arm2020,
  author   = {{Arm Limited}},
  date     = {2020},
  title    = {Arm Architecture Reference Manual},
  subtitle = {Armv8, for Armv8-A architecture profile},
  url      = {https://developer.arm.com/documentation/ddi0487/fc/},
  urldate  = {2025-05-11},
}

@Misc{RVSail,
  author = {{RISC-V International}},
  title  = {Sail RISC-V model},
  url    = {https://github.com/riscv/sail-riscv},
}

@Online{ArmISA,
  author  = {{Arm Limited}},
  title   = {Glossary: Instruction Set Architecture (ISA)},
  url     = {https://www.arm.com/glossary/isa},
  urldate = {2025-05-11},
}

@Manual{slaa685,
  author  = {Texas Instruments},
  date    = {2015},
  title   = {MSP Code Protection Features},
  url     = {https://www.ti.com/lit/an/slaa685/slaa685.pdf},
  urldate = {2025-05-14},
  file    = {:slaa685.pdf:PDF},
}

@Manual{slas704g,
  author  = {{Texas Instruments}},
  date    = {2018},
  title   = {MSP430FR596x, MSP430FR594x Mixed-Signal Microcontrollers},
  url     = {https://www.ti.com/lit/gpn/msp430fr5969},
  urldate = {2025-05-14},
  file    = {:msp430fr5969.pdf:PDF},
}

@Manual{slau367p,
  author  = {{Texas Instruments}},
  date    = {2020},
  title   = {MSP430FR58xx, MSP430FR59xx, andMSP430FR6xx Family},
  url     = {https://www.ti.com/lit/slau367},
  urldate = {2025-05-14},
  file    = {:slau367p.pdf:PDF},
}

@MastersThesis{mspthesis,
  author      = {Aaron Bogaert},
  institution = {Vrije Universiteit Brussels},
  title       = {Creating a Sail Specification for the MSP430 ISA and Extending it with Sancus},
}

@Article{Armstrong2018,
  author = {A. Armstrong and Thomas Bauereiss and B. Campbell and Shaked Flur and Kathryn E. Gray and Prashanth Mundkur and Robert M. Norton and Christopher Pulte and A. Reid and Peter Sewell and I. Stark and Mark Wassell},
  date   = {2018},
  title  = {Detailed Models of Instruction Set Architectures: From Pseudocode to Formal Semantics},
  url    = {https://www.semanticscholar.org/paper/5c124b1c96803138ef9c9f00038955ab14e63522},
  file   = {:Armstrong2018 - Detailed Models of Instruction Set Architectures_ from Pseudocode to Formal Semantics.pdf:PDF:https\://www.cl.cam.ac.uk/~pes20/sail/2018-04-12-arw-paper.pdf},
}

@InProceedings{Bognar2025,
  author    = {Bognar, Marton and Van Bulck, Jo},
  booktitle = {10th {IEEE} European Symposium on Security and Privacy (EuroS{\&}P)},
  date      = {2025},
  title     = {{openIPE}: An Extensible Memory Isolation Framework for Microcontrollers},
}

@Article{Keuchel2022,
  author     = {Keuchel, Steven and Huyghebaert, Sander and Lukyanov, Georgy and Devriese, Dominique},
  date       = {2022-08-31},
  title      = {Verified symbolic execution with Kripke specification monads (and no meta-programming)},
  doi        = {10.1145/3547628},
  pages      = {194–224},
  url        = {https://doi.org/10.1145/3547628},
  abstract   = {Verifying soundness of symbolic execution-based program verifiers is a  
significant challenge. This is especially true if the resulting tool needs to be  
usable outside of the proof assistant, in which case we cannot rely on shallowly  
embedded assertion logics and meta-programming. The tool needs to manipulate  
deeply embedded assertions, and it is crucial for efficiency to eagerly prune  
unreachable paths and simplify intermediate assertions in a way that can be  
justified towards the soundness proof. Only a few such tools exist in the  
literature, and their soundness proofs are intricate and hard to generalize or  
reuse. We contribute a novel, systematic approach for the construction and  
soundness proof of such a symbolic execution-based verifier. We first implement  
a shallow verification condition generator as an object language interpreter in  
a specification monad, using an abstract interface featuring angelic and demonic  
nondeterminism. Next, we build a symbolic executor by implementing a similar  
interpreter, in a symbolic specification monad. This symbolic monad lives in a  
universe that is Kripke-indexed by variables in scope and a path condition.  
Finally, we reduce the soundness of the symbolic execution to the soundness of  
the shallow execution by relating both executors using a Kripke logical  
relation. We report on the practical application of these techniques in  
Katamaran, a tool for verifying security guarantees offered by instruction set  
architectures (ISAs). The tool is fully verified by combining our symbolic  
execution machinery with a soundness proof of the shallow verification  
conditions against an axiomatized separation logic, and an Iris-based  
implementation of the axioms, proven sound against the operational semantics.  
Based on our experience with Katamaran, we can report good results on  
practicality and efficiency of the tool, demonstrating practical viability of  
our symbolic execution approach.},
  booktitle  = {Proc. ACM Program. Lang.},
  day        = {31},
  file       = {:Keuchel2022 - Verified Symbolic Execution with Kripke Specification Monads (and No Meta Programming).pdf:PDF:https\://dl.acm.org/doi/pdf/10.1145/3547628},
  groups     = {Katamaran},
  keywords   = {logical relations, predicate transformers, program verification, refinement, separation logic, symbolic execution},
  location   = {New York, NY, USA},
  pagetotal  = {31},
  publisher  = {Association for Computing Machinery},
  readstatus = {skimmed},
}

@Manual{ChipsAlliance,
  author  = {{Chips Alliance}},
  title   = {RISC-V VeeR EL2 Programmer's Reference Manual},
  chapter = {21 Physical Memory Protection},
  url     = {https://chipsalliance.github.io/Cores-VeeR-EL2/html/main/docs_rendered/html/physical-memory-protection.html},
  urldate = {2025-06-09},
}

@Online{SGX,
  author  = {{Intel Corporation}},
  title   = {Intel Software Guard Extension},
  url     = {https://www.intel.com/content/www/us/en/products/docs/accelerator-engines/software-guard-extensions.html},
  urldate = {2025-06-09},
}

@Report{Watson2023,
  author      = {Robert N. M. Watson and Peter G. Neumann and Jonathan Woodruff and Michael Roe and Hesham Almatary and Jonathan Anderson and John Baldwin and Graeme Barnes and David Chisnall and Jessica Clarke and Brooks Davis and Lee Eisen and Nathaniel Wesley Filardo and Franz A. Fuchs and Richard Grisenthwaite and Alexandre Joannou and Ben Laurie and A. Theodore Markettos and Simon W. Moore and Steven J. Murdoch and Kyndylan Nienhuis and Robert Norton and Alexander Richardson and Peter Rugg and Peter Sewell and Stacey Son and Hongyan Xia},
  date        = {2023},
  institution = {University of Cambridge, Computer Laboratory},
  title       = {Capability Hardware Enhanced RISC Instructions: CHERI Instruction-Set Architecture (Version 9)},
  type        = {techreport},
  isrn        = {UCAM-CL-TR-987},
}

@Article{Fei2021,
  author       = {Fei, Shufan and Yan, Zheng and Ding, Wenxiu and Xie, Haomeng},
  date         = {2021-07},
  journaltitle = {ACM Comput. Surv.},
  title        = {Security Vulnerabilities of SGX and Countermeasures: A Survey},
  doi          = {10.1145/3456631},
  issn         = {0360-0300},
  number       = {6},
  url          = {https://doi.org/10.1145/3456631},
  volume       = {54},
  abstract     = {Trusted Execution Environments (TEEs) have been widely used in many security-critical applications. The popularity of TEEs derives from its high security and trustworthiness supported by secure hardware. Intel Software Guard Extensions (SGX) is one of the most representative TEEs that creates an isolated environment on an untrusted operating system, thus providing run-time protection for the execution of security-critical code and data. However, Intel SGX is far from the acme of perfection. It has become a target of various attacks due to its security vulnerabilities. Researchers and practitioners have paid attention to the security vulnerabilities of SGX and investigated optimization solutions in real applications. Unfortunately, existing literature lacks a thorough review of security vulnerabilities of SGX and their countermeasures. In this article, we fill this gap. Specifically, we propose two sets of criteria for estimating security risks of existing attacks and evaluating defense effects brought by attack countermeasures. Furthermore, we propose a taxonomy of SGX security vulnerabilities and shed light on corresponding attack vectors. After that, we review published attacks and existing countermeasures, as well as evaluate them by employing our proposed criteria. At last, on the strength of our survey, we propose some open challenges and future directions in the research of SGX security.},
  articleno    = {126},
  issue_date   = {July 2022},
  keywords     = {trustworthiness, side-channel attacks, security, Trusted execution environment},
  location     = {New York, NY, USA},
  numpages     = {36},
  publisher    = {Association for Computing Machinery},
}

@Manual{slaa628b,
  author  = {{Texas Instruments}},
  date    = {2014},
  title   = {MSP430 FRAM Technology – How To and Best Practices},
  url     = {https://www.ti.com/lit/pdf/SLAA628},
  urldate = {2025-06-10},
}

@InProceedings{Ge2018,
  author    = {Ge, Qian and Yarom, Yuval and Heiser, Gernot},
  booktitle = {Proceedings of the 9th Asia-Pacific Workshop on Systems},
  date      = {2018},
  title     = {No Security Without Time Protection: We Need a New Hardware-Software Contract},
  doi       = {10.1145/3265723.3265724},
  isbn      = {9781450360067},
  location  = {Jeju Island, Republic of Korea},
  publisher = {Association for Computing Machinery},
  series    = {APSys '18},
  url       = {https://doi.org/10.1145/3265723.3265724},
  abstract  = {The recent Spectre exploits demonstrated that covert timing channels are a mainstream security threat. Their prevention requires that operating systems provide time protection, in addition to the established memory protection. We propose OS mechanisms and designs which provide time protection, and define requirements on the hardware to enable them. We demonstrate that present mainstream processors do not meet these requirements, making them inherently insecure. We argue the need for a new security-oriented hardware-software contract, which we call the aISA as it augments the ISA, in order to enable time protection.},
  address   = {New York, NY, USA},
  articleno = {1},
  numpages  = {9},
}

@InProceedings{Simner2020,
  author    = {Ben Simner and Shaked Flur and Christopher Pulte and Alasdair Armstrong and Jean Pichon-Pharabod and Luc Maranget and Peter Sewell},
  booktitle = {Proceedings of the 29th European Symposium on Programming, ESOP 2020},
  title     = {{ARMv8-A} system semantics: instruction fetch in relaxed architectures},
  abstract  = {Computing relies on \emph{architecture specifications} to decouple hardware and software development.  Historically these have been prose documents, with all the problems that entails, but research over the last ten years has developed rigorous and executable-as-test-oracle specifications of mainstream architecture instruction sets and ``user-mode'' concurrency, clarifying architectures and bringing them into the scope of programming-language semantics and verification.  However, the \emph{system semantics}, of instruction-fetch and cache maintenance, exceptions and interrupts, and address translation, remains obscure, leaving us without a solid foundation for verification of security-critical systems software.
    In this paper we establish a robust model for one aspect of system semantics: instruction fetch and cache maintenance for ARMv8-A.  Systems code relies on executing instructions that were written by data writes, e.g.~in program loading, dynamic linking, JIT compilation, debugging, and OS configuration, but hardware implementations are often highly optimised, e.g.~with instruction caches, linefill buffers, out-of-order fetching, branch prediction, and instruction prefetching, which can affect programmer-observable behaviour.  It is essential, both for programming and verification, to abstract from such microarchitectural details as much as possible, but no more.  We explore the key architecture design questions with a series of examples, discussed in detail with senior Arm staff; capture the architectural intent in operational and axiomatic semantic models, extending previous work on ``user-mode'' concurrency; make these models executable as test oracles for small examples; and experimentally validate them against hardware behaviour (finding a bug in one hardware device).  We thereby bring these subtle issues into the mathematical domain, clarifying the architecture and enabling future work on system software verification.},
  conf      = {ESOP 2020},
  optnote   = {This is an extended version of the ESOP 2020 paper, with appendices giving additional details},
  pdf       = {http://www.cl.cam.ac.uk/~pes20/iflat/top-extended.pdf},
  year      = {2020},
}

@InProceedings{Armstrong2021,
  author    = {Armstrong, Alasdair and Campbell, Brian and Simner, Ben and Pulte, Christopher and Sewell, Peter},
  booktitle = {Computer Aided Verification},
  date      = {2021},
  title     = {Isla: Integrating Full-Scale ISA Semantics and Axiomatic Concurrency Models},
  editor    = {Silva, Alexandra and Leino, K. Rustan M.},
  isbn      = {978-3-030-81685-8},
  location  = {Cham},
  pages     = {303--316},
  publisher = {Springer International Publishing},
  abstract  = {Architecture specifications such as Armv8-A and RISC-V are the ultimate foundation for software verification and the correctness criteria for hardware verification. They should define the allowed sequential and relaxed-memory concurrency behaviour of programs, but hitherto there has been no integration of full-scale instruction-set architecture (ISA) semantics with axiomatic concurrency models, either in mathematics or in tools. These ISA semantics can be surprisingly large and intricate, e.g. 100k+ lines for Armv8-A.},
}

@InProceedings{Sammler2022,
  author    = {Sammler, Michael and Hammond, Angus and Lepigre, Rodolphe and Campbell, Brian and Pichon-Pharabod, Jean and Dreyer, Derek and Garg, Deepak and Sewell, Peter},
  booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  date      = {2022},
  title     = {Islaris: verification of machine code against authoritative ISA semantics},
  doi       = {10.1145/3519939.3523434},
  isbn      = {9781450392655},
  location  = {San Diego, CA, USA},
  pages     = {825–840},
  publisher = {Association for Computing Machinery},
  series    = {PLDI 2022},
  url       = {https://doi.org/10.1145/3519939.3523434},
  abstract  = {Recent years have seen great advances towards verifying large-scale systems code. However, these verifications are usually based on hand-written assembly or machine-code semantics for the underlying architecture that only cover a small part of the instruction set architecture (ISA). In contrast, other recent work has used Sail to establish formal models for large real-world architectures, including Armv8-A and RISC-V, that are comprehensive (complete enough to boot an operating system or hypervisor) and authoritative (automatically derived from the Arm internal model and validated against the Arm validation suite, and adopted as the official formal specification by RISC-V International, respectively). But the scale and complexity of these models makes them challenging to use as a basis for verification. In this paper, we propose Islaris, the first system to support verification of machine code above these complete and authoritative real-world ISA specifications. Islaris uses a novel combination of SMT-solver-based symbolic execution (the Isla symbolic executor) and automated reasoning in a foundational program logic (a new separation logic we derive using Iris in Coq). We show that this approach can handle Armv8-A and RISC-V machine code exercising a wide range of systems features, including installing and calling exception vectors, code parametric on a relocation address offset (from the production pKVM hypervisor); unaligned access faults; memory-mapped IO; and compiled C code using inline assembly and function pointers.},
  address   = {New York, NY, USA},
  file      = {:/tmp/3519939.3523434.pdf:PDF},
  keywords  = {Arm, Coq, Iris, Isla, RISC-V, Sail, assembly, proof automation, separation logic, verification},
  numpages  = {16},
}

@InProceedings{Sammler2021,
  author    = {Sammler, Michael and Lepigre, Rodolphe and Krebbers, Robbert and Memarian, Kayvan and Dreyer, Derek and Garg, Deepak},
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  date      = {2021},
  title     = {RefinedC: automating the foundational verification of C code with refined ownership types},
  doi       = {10.1145/3453483.3454036},
  isbn      = {9781450383912},
  location  = {Virtual, Canada},
  pages     = {158–174},
  publisher = {Association for Computing Machinery},
  series    = {PLDI 2021},
  url       = {https://doi.org/10.1145/3453483.3454036},
  abstract  = {Given the central role that C continues to play in systems software, and the difficulty of writing safe and correct C code, it remains a grand challenge to develop effective formal methods for verifying C programs. In this paper, we propose a new approach to this problem: a type system we call RefinedC, which combines ownership types (for modular reasoning about shared state and concurrency) with refinement types (for encoding precise invariants on C data types and Hoare-style specifications for C functions). RefinedC is both automated (requiring minimal user intervention) and foundational (producing a proof of program correctness in Coq), while at the same time handling a range of low-level programming idioms such as pointer arithmetic. In particular, following the approach of RustBelt, the soundness of the RefinedC type system is justified semantically by interpretation into the Coq-based Iris framework for higher-order concurrent separation logic. However, the typing rules of RefinedC are also designed to be encodable in a new “separation logic programming” language we call Lithium. By restricting to a carefully chosen (yet expressive) fragment of separation logic, Lithium supports predictable, automatic, goal-directed proof search without backtracking. We demonstrate the effectiveness of RefinedC on a range of representative examples of C code.},
  address   = {New York, NY, USA},
  keywords  = {C programming language, Coq, Iris, ownership types, proof automation, refinement types, separation logic},
  numpages  = {17},
}

@InProceedings{Bauereiss2022,
  author    = {Bauereiss, Thomas and Campbell, Brian and Sewell, Thomas and Armstrong, Alasdair and Esswood, Lawrence and Stark, Ian and Barnes, Graeme and Watson, Robert N. M. and Sewell, Peter},
  booktitle = {Programming Languages and Systems},
  date      = {2022},
  title     = {Verified Security for the Morello Capability-enhanced Prototype Arm Architecture},
  editor    = {Sergey, Ilya},
  isbn      = {978-3-030-99336-8},
  location  = {Cham},
  pages     = {174--203},
  publisher = {Springer International Publishing},
  abstract  = {Memory safety bugs continue to be a major source of security vulnerabilities in our critical infrastructure. The CHERI project has proposed extending conventional architectures with hardware-supported capabilities to enable fine-grained memory protection and scalable compartmentalisation, allowing historically memory-unsafe C and C++ to be adapted to deterministically mitigate large classes of vulnerabilities, while requiring only minor changes to existing system software sources. Arm is currently designing and building Morello, a CHERI-enabled prototype architecture, processor, SoC, and board, extending the high-performance Neoverse N1, to enable industrial evaluation of CHERI and pave the way for potential mass-market adoption. However, for such a major new security-oriented architecture feature, it is important to establish high confidence that it does provide the intended protections, and that cannot be done with conventional engineering techniques.},
}

@Article{Georges2021,
  author       = {Georges, A\"{\i}na Linn and Gu\'{e}neau, Arma\"{e}l and Van Strydonck, Thomas and Timany, Amin and Trieu, Alix and Huyghebaert, Sander and Devriese, Dominique and Birkedal, Lars},
  date         = {2021-01},
  journaltitle = {Proc. ACM Program. Lang.},
  title        = {Efficient and provable local capability revocation using uninitialized capabilities},
  doi          = {10.1145/3434287},
  number       = {POPL},
  url          = {https://doi.org/10.1145/3434287},
  volume       = {5},
  abstract     = {Capability machines are a special form of CPUs that offer fine-grained privilege separation using a form of authority-carrying values known as capabilities. The CHERI capability machine offers local capabilities, which could be used as a cheap but restricted form of capability revocation. Unfortunately, local capability revocation is unrealistic in practice because large amounts of stack memory need to be cleared as a security precaution. In this paper, we address this shortcoming by introducing uninitialized capabilities: a new form of capabilities that represent read/write authority to a block of memory without exposing the memory’s initial contents. We provide a mechanically verified program logic for reasoning about programs on a capability machine with the new feature and we formalize and prove capability safety in the form of a universal contract for untrusted code. We use uninitialized capabilities for making a previously-proposed secure calling convention efficient and prove its security using the program logic. Finally, we report on a proof-of-concept implementation of uninitialized capabilities on the CHERI capability machine.},
  articleno    = {6},
  issue_date   = {January 2021},
  keywords     = {universal contracts, uninitialized capabilities, program logic, local capabilities, capability safety, capability revocation, capability machines, CHERI},
  location     = {New York, NY, USA},
  numpages     = {30},
  publisher    = {Association for Computing Machinery},
}

@InProceedings{Jensen2013,
  author    = {Jensen, Jonas B. and Benton, Nick and Kennedy, Andrew},
  booktitle = {Proceedings of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  date      = {2013},
  title     = {High-level separation logic for low-level code},
  doi       = {10.1145/2429069.2429105},
  isbn      = {9781450318327},
  location  = {Rome, Italy},
  pages     = {301–314},
  publisher = {Association for Computing Machinery},
  series    = {POPL '13},
  url       = {https://doi.org/10.1145/2429069.2429105},
  abstract  = {Separation logic is a powerful tool for reasoning about structured, imperative programs that manipulate pointers. However, its application to unstructured, lower-level languages such as assembly language or machine code remains challenging. In this paper we describe a separation logic tailored for this purpose that we have applied to x86 machine-code programs.The logic is built from an assertion logic on machine states over which we construct a specification logic that encapsulates uses of frames and step indexing. The traditional notion of Hoare triple is not applicable directly to unstructured machine code, where code and data are mixed together and programs do not in general run to completion, so instead we adopt a continuation-passing style of specification with preconditions alone. Nevertheless, the range of primitives provided by the specification logic, which include a higher-order frame connective, a novel read-only frame connective, and a 'later' modality, support the definition of derived forms to support structured-programming-style reasoning for common cases, in which standard rules for Hoare triples are derived as lemmas. Furthermore, our encoding of scoped assembly-language labels lets us give definitions and proof rules for powerful assembly-language 'macros' such as while loops, conditionals and procedures.We have applied the framework to a model of sequential x86 machine code built entirely within the Coq proof assistant, including tactic support based on computational reflection.},
  address   = {New York, NY, USA},
  keywords  = {separation logic, proof assistants, machine code},
  numpages  = {14},
}

@InProceedings{Nelson2019,
  author    = {Nelson, Luke and Bornholt, James and Gu, Ronghui and Baumann, Andrew and Torlak, Emina and Wang, Xi},
  booktitle = {Proceedings of the 27th ACM Symposium on Operating Systems Principles},
  date      = {2019},
  title     = {Scaling symbolic evaluation for automated verification of systems code with Serval},
  doi       = {10.1145/3341301.3359641},
  isbn      = {9781450368735},
  location  = {Huntsville, Ontario, Canada},
  pages     = {225–242},
  publisher = {Association for Computing Machinery},
  series    = {SOSP '19},
  url       = {https://doi.org/10.1145/3341301.3359641},
  abstract  = {This paper presents Serval, a framework for developing automated verifiers for systems software. Serval provides an extensible infrastructure for creating verifiers by lifting interpreters under symbolic evaluation, and a systematic approach to identifying and repairing verification performance bottlenecks using symbolic profiling and optimizations.Using Serval, we build automated verifiers for the RISC-V, x86--32, LLVM, and BPF instruction sets. We report our experience of retrofitting CertiKOS and Komodo, two systems previously verified using Coq and Dafny, respectively, for automated verification using Serval, and discuss trade-offs of different verification methodologies. In addition, we apply Serval to the Keystone security monitor and the BPF compilers in the Linux kernel, and uncover 18 new bugs through verification, all confirmed and fixed by developers.},
  address   = {New York, NY, USA},
  numpages  = {18},
}

@Article{Guanciale2016,
  author       = {Guanciale, Roberto and Nemati, Hamed and Dam, Mads and Baumann, Christoph},
  date         = {2016-01},
  journaltitle = {J. Comput. Secur.},
  title        = {Provably secure memory isolation for Linux on ARM},
  doi          = {10.3233/JCS-160558},
  issn         = {0926-227X},
  number       = {6},
  pages        = {793–837},
  url          = {https://doi.org/10.3233/JCS-160558},
  volume       = {24},
  abstract     = {The isolation of security critical components from an untrusted OS allows to both protect applications and to harden the OS itself. Virtualization of the memory subsystem is a key component to provide such isolation. We present the design, implementation and verification of a memory virtualization platform for ARMv7-A processors. The design is based on direct paging, an MMU virtualization mechanism previously introduced by Xen. It is shown that this mechanism can be implemented using a compact design, suitable for formal verification down to a low level of abstraction, without penalizing system performance. The verification is performed using the HOL4 theorem prover and uses a detailed model of the processor. We prove memory isolation along with information flow security for an abstract top-level model of the virtualization mechanism. The abstract model is refined down to a transition system closely resembling a C implementation. Additionally, it is demonstrated how the gap between the low-level abstraction and the binary level-can be filled, using tools that check Hoare contracts. The virtualization mechanism is demonstrated on real hardware via a hypervisor hosting Linux and supporting a tamper-proof run-time monitor that provably prevents code injection in the Linux guest.},
  issue_date   = {2016},
  keywords     = {hypervisor, separation kernel, information flow security, Formal verification},
  location     = {NLD},
  numpages     = {45},
  publisher    = {IOS Press},
}

@Article{Armstrong2019,
  author       = {Armstrong, Alasdair and Bauereiss, Thomas and Campbell, Brian and Reid, Alastair and Gray, Kathryn E. and Norton, Robert M. and Mundkur, Prashanth and Wassell, Mark and French, Jon and Pulte, Christopher and Flur, Shaked and Stark, Ian and Krishnaswami, Neel and Sewell, Peter},
  date         = {2019-01},
  journaltitle = {Proc. ACM Program. Lang.},
  title        = {ISA semantics for ARMv8-a, RISC-v, and CHERI-MIPS},
  doi          = {10.1145/3290384},
  number       = {POPL},
  url          = {https://doi.org/10.1145/3290384},
  volume       = {3},
  abstract     = {Architecture specifications notionally define the fundamental interface between hardware and software: the envelope of allowed behaviour for processor implementations, and the basic assumptions for software development and verification. But in practice, they are typically prose and pseudocode documents, not rigorous or executable artifacts, leaving software and verification on shaky ground.  In this paper, we present rigorous semantic models for the sequential behaviour of large parts of the mainstream ARMv8-A, RISC-V, and MIPS architectures, and the research CHERI-MIPS architecture, that are complete enough to boot operating systems, variously Linux, FreeBSD, or seL4. Our ARMv8-A models are automatically translated from authoritative ARM-internal definitions, and (in one variant) tested against the ARM Architecture Validation Suite.  We do this using a custom language for ISA semantics, Sail, with a lightweight dependent type system, that supports automatic generation of emulator code in C and OCaml, and automatic generation of proof-assistant definitions for Isabelle, HOL4, and (currently only for MIPS) Coq. We use the former for validation, and to assess specification coverage. To demonstrate the usability of the latter, we prove (in Isabelle) correctness of a purely functional characterisation of ARMv8-A address translation. We moreover integrate the RISC-V model into the RMEM tool for (user-mode) relaxed-memory concurrency exploration. We prove (on paper) the soundness of the core Sail type system.  We thereby take a big step towards making the architectural abstraction actually well-defined, establishing foundations for verification and reasoning.},
  articleno    = {71},
  issue_date   = {January 2019},
  keywords     = {Instruction Set Architectures, Semantics, Theorem Proving},
  location     = {New York, NY, USA},
  numpages     = {31},
  publisher    = {Association for Computing Machinery},
}

@InProceedings{Reid2016a,
  author    = {Reid, Alastair and Chen, Rick and Deligiannis, Anastasios and Gilday, David and Hoyes, David and Keen, Will and Pathirane, Ashan and Shepherd, Owen and Vrabel, Peter and Zaidi, Ali},
  booktitle = {Computer Aided Verification},
  date      = {2016},
  title     = {End-to-End Verification of Processors with ISA-Formal},
  editor    = {Chaudhuri, Swarat and Farzan, Azadeh},
  isbn      = {978-3-319-41540-6},
  location  = {Cham},
  pages     = {42--58},
  publisher = {Springer International Publishing},
  abstract  = {Despite 20+ years of research on processor verification, it remains hard to use formal verification techniques in commercial processor development. There are two significant factors: scaling issues and return on investment. The scaling issues include the size of modern processor specifications, the size/complexity of processor designs, the size of design/verification teams and the (non)availability of enough formal verification experts. The return on investment issues include the need to start catching bugs early in development, the need to continue catching bugs throughout development, and the need to be able to reuse verification IP, tools and techniques across a wide range of design styles.},
}

@Comment{jabref-meta: databaseType:biblatex;}

@Comment{jabref-meta: fileDirectory:/home/ale/documenti/uni/magistrale/tesi/ref/pdfs;}
